/* Blob.js
 * A Blob implementation.
 * 2013-06-20
 * 
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

if (typeof Blob !== "function" || typeof URL === "undefined")
if (typeof Blob === "function" && typeof webkitURL !== "undefined") var URL = webkitURL;
else var Blob = (function (view) {
    "use strict";

    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder || (function(view) {
        var
              get_class = function(object) {
                return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
            }
            , FakeBlobBuilder = function BlobBuilder() {
                this.data = [];
            }
            , FakeBlob = function Blob(data, type, encoding) {
                this.data = data;
                this.size = data.length;
                this.type = type;
                this.encoding = encoding;
            }
            , FBB_proto = FakeBlobBuilder.prototype
            , FB_proto = FakeBlob.prototype
            , FileReaderSync = view.FileReaderSync
            , FileException = function(type) {
                this.code = this[this.name = type];
            }
            , file_ex_codes = (
                  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
                + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
            ).split(" ")
            , file_ex_code = file_ex_codes.length
            , real_URL = view.URL || view.webkitURL || view
            , real_create_object_URL = real_URL.createObjectURL
            , real_revoke_object_URL = real_URL.revokeObjectURL
            , URL = real_URL
            , btoa = view.btoa
            , atob = view.atob
            , can_apply_typed_arrays = false
            , can_apply_typed_arrays_test = function(pass) {
                can_apply_typed_arrays = !pass;
            }
            
            , ArrayBuffer = view.ArrayBuffer
            , Uint8Array = view.Uint8Array
        ;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        try {
            if (Uint8Array) {
                can_apply_typed_arrays_test.apply(0, new Uint8Array(1));
            }
        } catch (ex) {}
        if (!real_URL.createObjectURL) {
            URL = view.URL = {};
        }
        URL.createObjectURL = function(blob) {
            var
                  type = blob.type
                , data_URI_header
            ;
            if (type === null) {
                type = "application/octet-stream";
            }
            if (blob instanceof FakeBlob) {
                data_URI_header = "data:" + type;
                if (blob.encoding === "base64") {
                    return data_URI_header + ";base64," + blob.data;
                } else if (blob.encoding === "URI") {
                    return data_URI_header + "," + decodeURIComponent(blob.data);
                } if (btoa) {
                    return data_URI_header + ";base64," + btoa(blob.data);
                } else {
                    return data_URI_header + "," + encodeURIComponent(blob.data);
                }
            } else if (real_create_object_URL) {
                return real_create_object_URL.call(real_URL, blob);
            }
        };
        URL.revokeObjectURL = function(object_URL) {
            if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                real_revoke_object_URL.call(real_URL, object_URL);
            }
        };
        FBB_proto.append = function(data/*, endings*/) {
            var bb = this.data;
            // decode data to a binary string
            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                if (can_apply_typed_arrays) {
                    bb.push(String.fromCharCode.apply(String, new Uint8Array(data)));
                } else {
                    var
                          str = ""
                        , buf = new Uint8Array(data)
                        , i = 0
                        , buf_len = buf.length
                    ;
                    for (; i < buf_len; i++) {
                        str += String.fromCharCode(buf[i]);
                    }
                }
            } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                if (FileReaderSync) {
                    var fr = new FileReaderSync;
                    bb.push(fr.readAsBinaryString(data));
                } else {
                    // async FileReader won't work as BlobBuilder is sync
                    throw new FileException("NOT_READABLE_ERR");
                }
            } else if (data instanceof FakeBlob) {
                if (data.encoding === "base64" && atob) {
                    bb.push(atob(data.data));
                } else if (data.encoding === "URI") {
                    bb.push(decodeURIComponent(data.data));
                } else if (data.encoding === "raw") {
                    bb.push(data.data);
                }
            } else {
                if (typeof data !== "string") {
                    data += ""; // convert unsupported types to strings
                }
                // decode UTF-16 to binary string
                bb.push(unescape(encodeURIComponent(data)));
            }
        };
        FBB_proto.getBlob = function(type) {
            if (!arguments.length) {
                type = null;
            }
            return new FakeBlob(this.data.join(""), type, "raw");
        };
        FBB_proto.toString = function() {
            return "[object BlobBuilder]";
        };
        FB_proto.slice = function(start, end, type) {
            var args = arguments.length;
            if (args < 3) {
                type = null;
            }
            return new FakeBlob(
                  this.data.slice(start, args > 1 ? end : this.data.length)
                , type
                , this.encoding
            );
        };
        FB_proto.toString = function() {
            return "[object Blob]";
        };
        return FakeBlobBuilder;
    }(view));

    return function Blob(blobParts, options) {
        var type = options ? (options.type || "") : "";
        var builder = new BlobBuilder();
        if (blobParts) {
            for (var i = 0, len = blobParts.length; i < len; i++) {
                builder.append(blobParts[i]);
            }
        }
        return builder.getBlob(type);
    };
}(self));
/* canvas-toBlob.js
 * A canvas.toBlob() implementation.
 * 2011-07-13
 * 
 * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

(function(view) {
"use strict";
var
      Uint8Array = view.Uint8Array
    , HTMLCanvasElement = view.HTMLCanvasElement
    , is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i
    , base64_ranks
    , decode_base64 = function(base64) {
        var
              len = base64.length
            , buffer = new Uint8Array(len / 4 * 3 | 0)
            , i = 0
            , outptr = 0
            , last = [0, 0]
            , state = 0
            , save = 0
            , rank
            , code
            , undef
        ;
        while (len--) {
            code = base64.charCodeAt(i++);
            rank = base64_ranks[code-43];
            if (rank !== 255 && rank !== undef) {
                last[1] = last[0];
                last[0] = code;
                save = (save << 6) | rank;
                state++;
                if (state === 4) {
                    buffer[outptr++] = save >>> 16;
                    if (last[1] !== 61 /* padding character */) {
                        buffer[outptr++] = save >>> 8;
                    }
                    if (last[0] !== 61 /* padding character */) {
                        buffer[outptr++] = save;
                    }
                    state = 0;
                }
            }
        }
        // 2/3 chance there's going to be some null bytes at the end, but that
        // doesn't really matter with most image formats.
        // If it somehow matters for you, truncate the buffer up outptr.
        return buffer.buffer;
    }
;
if (Uint8Array) {
    base64_ranks = new Uint8Array([
          62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1
        , -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9
        , 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
        , -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
        , 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    ]);
}
if (HTMLCanvasElement && !HTMLCanvasElement.prototype.toBlob) {
    HTMLCanvasElement.prototype.toBlob = function(callback, type /*, ...args*/) {
          if (!type) {
            type = "image/png";
        } if (this.mozGetAsFile) {
            callback(this.mozGetAsFile("canvas", type));
            return;
        }
        var
              args = Array.prototype.slice.call(arguments, 1)
            , dataURI = this.toDataURL.apply(this, args)
            , header_end = dataURI.indexOf(",")
            , data = dataURI.substring(header_end + 1)
            , is_base64 = is_base64_regex.test(dataURI.substring(0, header_end))
            , blob
        ;
        if (Blob.fake) {
            // no reason to decode a data: URI that's just going to become a data URI again
            blob = new Blob
            if (is_base64) {
                blob.encoding = "base64";
            } else {
                blob.encoding = "URI";
            }
            blob.data = data;
            blob.size = data.length;
        } else if (Uint8Array) {
            if (is_base64) {
                blob = new Blob([decode_base64(data)], {type: type});
            } else {
                blob = new Blob([decodeURIComponent(data)], {type: type});
            }
        }
        callback(blob);
    };
}
}(self));
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-01-23
 * 
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))
  || (function(view) {
    "use strict";
    var
          doc = view.document
          // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
        , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , URL = view.URL || view.webkitURL || view
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link = "download" in save_link
        , click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent(
                "click", true, false, view, 0, 0, 0, 0, 0
                , false, false, false, false, 0, null
            );
            node.dispatchEvent(event);
        }
        , webkit_req_fs = view.webkitRequestFileSystem
        , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
        , throw_outside = function (ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        , fs_min_size = 0
        , deletion_queue = []
        , process_deletion_queue = function() {
            var i = deletion_queue.length;
            while (i--) {
                var file = deletion_queue[i];
                if (typeof file === "string") { // file is an object URL
                    URL.revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            }
            deletion_queue.length = 0; // clear queue
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , FileSaver = function(blob, name) {
            // First try a.download, then web filesystem, then object URLs
            var
                  filesaver = this
                , type = blob.type
                , blob_changed = false
                , object_url
                , target_view
                , get_object_url = function() {
                    var object_url = get_URL().createObjectURL(blob);
                    deletion_queue.push(object_url);
                    return object_url;
                }
                , dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function() {
                    // don't create more object URLs than needed
                    if (blob_changed || !object_url) {
                        object_url = get_object_url(blob);
                    }
                    if (target_view) {
                        target_view.location.href = object_url;
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                }
                , abortable = function(func) {
                    return function() {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                }
                , create_if_not_found = {create: true, exclusive: false}
                , slice
            ;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_object_url(blob);
                save_link.href = object_url;
                save_link.download = name;
                click(save_link);
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                return;
            }
            // Object and web filesystem URLs have a problem saving in Google Chrome when
            // viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // Since I can't be sure that the guessed media type will trigger a download
            // in WebKit, I append .download to the filename.
            // https://bugs.webkit.org/show_bug.cgi?id=65440
            if (webkit_req_fs && name !== "download") {
                name += ".download";
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            } else {
                target_view = view.open();
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL();
                                    deletion_queue.push(file);
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, "writeend", event);
                                };
                                writer.onerror = function() {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function() {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {create: false}, abortable(function(file) {
                        // delete file if it already exists
                        file.remove();
                        save();
                    }), abortable(function(ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        }
    ;
    FS_proto.abort = function() {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;
    
    FS_proto.error =
    FS_proto.onwritestart =
    FS_proto.onprogress =
    FS_proto.onwrite =
    FS_proto.onabort =
    FS_proto.onerror =
    FS_proto.onwriteend =
        null;
    
    view.addEventListener("unload", process_deletion_queue, false);
    return saveAs;
}(self));
$(function () {
    $imageArea = $('#image-area');
    $imageArea.append($('<canvas>')[0]);
    $imageArea.append($('<canvas class="fake-canvas">')[0]);
    var fakeCanvas = new fabric.Canvas($('.fake-canvas')[0]);
    var canvas = new fabric.Canvas($imageArea.children('canvas')[0]);
    canvas.setHeight($imageArea.height());
    canvas.setWidth($imageArea.width());
    fakeCanvas.setHeight($imageArea.height());
    fakeCanvas.setWidth($imageArea.width());
    canvas.selection = false;

    //var imgElement = canvas.setBackgroundImage('img/logo.png', canvas.renderAll.bind(canvas));
    canvas.setBackgroundImage('img/logo.png', canvas.renderAll.bind(canvas), {
      left: 0,
      top: 0
    }, null, {crossOrigin: 'Anonymous'});
    var logoText = new fabric.IText('and', {
        left: 310,
        top: 395,
        lineHeight: 1,
        padding: 7,
        fill: '#fff',
        fontFamily: 'Riesling',
        hasRotatingPoint: !1,
        hasControls: !1,
        hasBorders: !1,
        hoverCursor: 'text', 
        moveCursor: 'text', 
        originX: "center",
        originY: "center",
        textAlign: "center",
        lockMovementX: !0,
        lockMovementY: !0,
        lockRotation: !0,
        lockScalingX: !0,
        lockScalingY: !0,
        fontSize: 95,
        multiline: !1,
        capitalize: !0,
        cursorHeightPercent: .6,
        selectionHeightPercent: .7,
        letterSpace: 15,
        maxLength: 20,
        maxInputWidth: 220,
        selectionColor: "rgba(0,0,0,0.3)",
        cursorWidth: 2,
        cursorColor: "#888",
        cursorDelay:0,
        cursorDuration:300
    });
    canvas.add(logoText).setActiveObject(logoText);
    logoText.enterEditing();

    var editor = $('#image').cropper({
        viewMode: 3,
        dragMode: 'move',
        autoCropArea: 1,
        modal: false,
        guides: false,
        highlight: false,
        cropBoxMovable: false,
        cropBoxResizable: false
    });

    var $inputImage = $('#inputImage');
    var URL = window.URL || window.webkitURL;
    var blobURL;
    $('.btn-upload').on('click', function(){
        logoText.exitEditing();
    });
    $('.btn-desaturate').on('click', function(){
        if ($(this).hasClass('disabled')) {
            return;
        }
        if ($(this).hasClass('active')) {
            editor.cropper('saturateCanvasObj');
            $(this).removeClass('active');
        } else {
            editor.cropper('desaturateCanvasObj');
            $(this).addClass('active');
        }
    });
    $('.btn-download').on('click', function(){
        if ($(this).hasClass('disabled')) {
            return;
        }
        var canvasData = editor.cropper('getCropBoxData'),
            imageCanvas = editor.cropper('getCroppedCanvas', {
            width: canvasData.width,
            height: canvasData.height
        });
        fabric.Image.fromURL(imageCanvas.toDataURL(), function(img) {
            img.left = 0;
            img.top = 0;
            img.set({
                evented: false
              });
            fakeCanvas.add(img);
            img.sendBackwards();
        });
        fabric.Image.fromURL(canvas.toDataURL(), function(img) {
            img.left = 0;
            img.top = 0;
            img.set({
                evented: false
              });
            fakeCanvas.add(img);
            img.bringToFront();

        });
        setTimeout(function(){
            fakeCanvas.lowerCanvasEl.toBlob(function(t) {
                return saveAs(t, "sample");
            }, "image/jpeg");
        }, 2000);
        
    });
    if (URL) {
        $inputImage.change(function () {

            var files = this.files;
            var file;

            if (!editor.data('cropper')) {
                return;
            }

            if (files && files.length) {
                file = files[0];

                if (/^image\/\w+$/.test(file.type)) {
                  blobURL = URL.createObjectURL(file);
                  editor.one('built.cropper', function () {
                    $('.btn-desaturate, .btn-download').removeClass('disabled');
                    $('.btn-desaturate').removeClass('active');
                    // Revoke when load complete
                    URL.revokeObjectURL(blobURL);
                  }).cropper('reset').cropper('replace', blobURL);
                  $inputImage.val('');
                } else {
                  window.alert('Please choose an image file.');
                }
            }
        });
    } else {
        $inputImage.prop('disabled', true).parent().addClass('disabled');
    }    
});